/*
 * Created by William Wyatt
 * On Aug 30th 2017
 * Make some vector utilities.
 */
#ifndef WILLIAMS_FUN_TIME
#define WILLIAMS_FUN_TIME 1

#include <string>
#include <vector>
#include <map>
#include <iostream>
#include <cmath>

#include "lcio.h"
#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>

using namespace lcio;
using namespace std;
namespace Will{
  struct fourvec;
  double getTMag(const double*);

  struct fourvec{
    union{ double X; double x=0.0; };
    union{ double Y; double y=0.0; };
    union{ double Z; double z=0.0; };
    union{ double E; double e=0.0; };
    union{ double T; double t=0.0; };
    fourvec operator+(const fourvec& a) const{
      return fourvec(
		     a.x+x,
		     a.y+y,
		     a.z+z,
		     a.e+e,
		     sqrt(pow(a.x+x,2)+pow(a.y+y,2))
		     );
    }
    double operator*(const fourvec& a) const{
      return a.x*x + a.y*y + a.z*z;
    }
    fourvec operator+=(const fourvec& a){
      *this=a+*this;
      return *this;
    }
    fourvec(const double _x,const double _y){x=_x;y=_y;t=getTMag(new double[2]{_x,_y});}
    fourvec(const double _x,const double _y,const double _z):fourvec(_x,_y){z=_z;}
    fourvec(const double _x,const double _y,const double _z,const double _e):fourvec(_x,_y,_z){e=_e;}
    fourvec(const double _x,const double _y,const double _z,const double _e,const double _t):fourvec(_x,_y,_z,_e){t=_t;}
    fourvec():fourvec(0,0,0,0,0){};
    fourvec(const double* input,const unsigned short SIZE){
      switch(SIZE){
      case 4:
	e=input[3];
      case 3:
	z=input[2];
      case 2:
	t=getTMag(new double[2]{input[0], input[1]});
	y=input[1];
      case 1:
	x=input[0];
      }
    }
  };
  struct prediction{
    fourvec electron;
    fourvec positron;
    prediction(double x,double y){
      electron.x=x;
      positron.y=y;
    };
  };
  struct measure{
    fourvec hadronic;
    fourvec electronic;
    fourvec electron;
    fourvec positron;
    double mag=0.0;
    bool scattered=false;
  };
  //Specific function used in prediction algorithm.
  //Finds the highest energy particle
   map<int,double> maxEnergy(LCCollection*, 
			     initializer_list<int> ids, 
			     vector<MCParticle*>& final_state);

   double* getVector(MCParticle*);
   fourvec getFourVector(MCParticle*);

   //Returns the sum of the two; assumes a 4 vector
   double* addVector(double*, double*, const int SIZE=4);

   //Returns transverse momentum magnitude
   double getTMag(const fourvec);

   //Returns momentum from a momentum vector
   double getMag(const double*);
   double getMag(const fourvec);

   //Returns angle off of the z-axis, theta
   double getTheta(const double*);
   double getTheta(const fourvec);

   //Returns dot product of two vectors
   double getDot(const double*, const double*);
   double getDot(const fourvec, const fourvec);

   //Retuns anglebetween vectors or doubles in rads
   double getTheta(const double*, const double*);
   double getTheta(const fourvec, const fourvec);

   

   double* legacy(fourvec);


  /*Returns a map with a few four vectors in it.
   * - hadronic vector
   * - electronic vector
   * - electron vector
   * - positron vector
   * This should be used to calculate a prediction vector.
   */
   measure getMeasure(LCCollection*);
}

#endif
